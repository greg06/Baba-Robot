package com.robot.baba;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Set;
import java.util.UUID;

import android.bluetooth.BluetoothAdapter;			// Classe qui représente le module bluetooth de votre Android, elle permet de scanner les périphériques présents, d'activer / désactiver le bluetooth, ...
import android.bluetooth.BluetoothDevice;			// Classe qui représente un périphérique bluetooth
import android.bluetooth.BluetoothSocket;			// Classe qui permet d'obtenir les canaux d'écriture (émission) et de lecture (réception) du périphérique
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

public class Communication_bluetooth {
    public static final char OCTET_START = '0';
    public static final char OCTET_FIN_1 = '8';
    public static final char OCTET_FIN_2 = '9';
    
	private BluetoothDevice device = null;			// le périphérique (le module bluetooth)
	private BluetoothSocket socket = null; 
	private InputStream receiveStream = null;		// Canal de réception
	private OutputStream sendStream = null;			// Canal d'émission
	
	private ReceiverThread receiverThread;			// On créer le thread de réception des données avec l'Handler venant du thread UI

	Handler handler;

	public Communication_bluetooth(Handler hstatus, Handler h) {
		// On récupère la liste des périphériques associés
		Set<BluetoothDevice> setpairedDevices = BluetoothAdapter.getDefaultAdapter().getBondedDevices();
		BluetoothDevice[] pairedDevices = (BluetoothDevice[]) setpairedDevices.toArray(new BluetoothDevice[setpairedDevices.size()]);
		
		// On parcours la liste pour trouver notre module bluetooth
		for(int i=0;i<pairedDevices.length;i++) {
			 // On teste si ce périphérique contient le nom du module bluetooth connecté au microcontrôleur
			if(pairedDevices[i].getName().contains("Bluetooth_V3")) {
				device = pairedDevices[i];
				try {
					// On récupère le socket de notre périphérique
					socket = device.createRfcommSocketToServiceRecord(UUID.fromString("00001101-0000-1000-8000-00805F9B34FB"));
					receiveStream = socket.getInputStream();		// Canal de réception (valide uniquement après la connexion)
					sendStream = socket.getOutputStream();			// Canal d'émission (valide uniquement après la connexion)
				} catch (IOException e) {
					e.printStackTrace();
				}
				break;
			}
		}

		handler = hstatus;
		
		receiverThread = new ReceiverThread(h);
	}
	
	public void sendData(String data) {
		sendData(data, false);
	}
	
	// Pour envoyer des données, on va tout simplement utiliser les fonctions write(...) de OutputStream
	public void sendData(String data, boolean deleteScheduledData) {
		try {									
			sendStream.write(data.getBytes());						// On écrit les données dans le buffer d'envoi
	        sendStream.flush();										// On s'assure qu'elles soient bien envoyés
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
    public void trame_envoi(char adresse, char fonction, char donnee)
    { 	 
		 StringBuffer trame = new StringBuffer();
		 trame = trame.append(OCTET_START).append(adresse).append(fonction).append(donnee).append(OCTET_FIN_1).append(OCTET_FIN_2);
		 
		 sendData( trame.toString());
    }
	
	// Pour se connecter, on utilise la fonction connect(); de BluetoothSocket. 
	// La connexion pouvant prendre du temps, il est nécessaire de la lancer dans un autre thread pour éviter de bloquer l'application.
	public void connect() {
		new Thread() {
			@Override 
			public void run() {
				try {
					socket.connect();								// Tentative de connexion
																	// Connexion réussie
					Message msg = handler.obtainMessage();
					msg.arg1 = 1;
	                handler.sendMessage(msg);
	                
					receiverThread.start();
					
				} catch (IOException e) {							// Echec de la connexion
					Log.v("Baba", "Connection Failed : "+e.getMessage());
					e.printStackTrace();
				}
			}
		}.start();
	}

	// Enfin, pour fermer la connexion, il y a la fonction close() de BluetoothSocket
	public void close() {
		try {
			socket.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public BluetoothDevice getDevice() {
		return device;
	}
	
	
	// Pour recevoir des données, le plus simple est de faire un Thread qui va vérifier l'arrivé de données en permanence. 
	// On utilise les fonctions read(...) et available() de InputStream pour lire ces données et vérifier si de nouvelles sont disponibles.
	
	// Problème : on ne peut afficher les données depuis ce nouveau thread : android impose de les envoyées dans le thread de l'UI. 
	// On utilise donc la classe Handler. On doit alors modifier le constructeur pour récupérer un Handler du thread de l'UI.
	private class ReceiverThread extends Thread {
		Handler handler;
		
		ReceiverThread(Handler h) {
			handler = h;
		}
		
		@Override public void run() {
			while(true) {
				try {
					if(receiveStream.available() > 0) {				// On teste si des données sont disponibles

						byte buffer[] = new byte[100];
						int k = receiveStream.read(buffer, 0, 100);	// On lit les données, k représente le nombre de bytes lu

						if(k > 0) {
							byte rawdata[] = new byte[k];
							for(int i=0;i<k;i++)
								rawdata[i] = buffer[i];
							
							String data = new String(rawdata);		// On convertit les données en String

							Message msg = handler.obtainMessage();	// On envoie les données dans le thread de l'UI pour les affichées
							Bundle b = new Bundle();
							b.putString("receivedData", data);
			                msg.setData(b);
			                handler.sendMessage(msg);
						}
					}
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
